# <center> RUST æ ‡å‡†åº“
## ä¸€ã€å­—ç¬¦ä¸²
#### 1.å­—ç¬¦ä¸²ç±»å‹
* Rustçš„å­—ç¬¦ä¸²å¤„ç†æœºåˆ¶æ¯”è¾ƒå¤æ‚ã€‚
  * ä¸»è¦æ˜¯ç”¨UTF_8ç¼–ç çš„Unicodeå­—ç¬¦åºåˆ—
  * ä¸æ˜¯ç©ºå­—ç¬¦'\0'ç»“å°¾çš„ C é£æ ¼å­—ç¬¦ä¸²ï¼Œå¯ä»¥åŒ…å«ç©ºå­—ç¬¦ã€‚
* ä¸»è¦æœ‰ä¸¤å¤§ç±»ï¼š`&str` å’Œ `String`ã€‚

#### 2.å­—ç¬¦ç¼–ç 
* **ç¼–ç **ï¼šå­—ç¬¦åœ¨è®¡ç®—æœºå†…éƒ¨çš„è¡¨ç¤ºæ–¹å¼
* **æ—©æœŸ**ï¼šASCII ç ï¼Œä»¥è‹±æ–‡å­—ç¬¦ä¸ºä¸»ï¼Œ7 ä½äºŒè¿›åˆ¶
* **ä¸­æ–‡**ï¼šGB 2312-1980ã€Šä¿¡æ¯äº¤æ¢ç”¨æ±‰å­—ç¼–ç å­—ç¬¦é›†ã€‹ï¼Œ6,763 ä¸ªæ±‰å­—ï¼Œä¸¤ä¸ªå­—èŠ‚
  * GB 18030-2005ã€Šä¿¡æ¯æŠ€æœ¯ä¸­æ–‡ç¼–ç å­—ç¬¦é›†ã€‹ï¼Œ70,244 ä¸ªæ±‰å­—ï¼Œä¸¤ä¸ªå­—èŠ‚æˆ–å››ä¸ªå­—èŠ‚
* **Unicode**ï¼šè¯•å›¾æŠŠå…¨ä¸–ç•Œçš„æ–‡å­—éƒ½çº³å…¥è¿›æ¥ï¼Œæ”¶é›†äº† 144,697 ä¸ªå­—ç¬¦ï¼Œå››ä¸ªå­—èŠ‚
  * å¸¸ç”¨ UTF-8 çš„å½¢å¼æ¥è¡¨ç¤ºï¼Œå˜é•¿ä¸€åˆ°å››ä¸ªå­—èŠ‚

#### 3.ä¹±ç é—®é¢˜
**<center> Unicodeä¸­æ–‡ä¹±ç é€ŸæŸ¥è¡¨**</center>
![ä¹±ç è¡¨](assets/01.png)

#### 4.&str
* `&str` æ˜¯å­—ç¬¦ä¸²åˆ‡ç‰‡ï¼Œæ˜¯åˆ‡ç‰‡çš„ä¸€ç§ã€‚
* å½¢å¦‚ "string literals" çš„å­—ç¬¦ä¸²å­—é¢å€¼æ˜¯ `&str` ç±»å‹çš„1ã€‚
* ä¸èƒ½ç”¨æ–¹æ‹¬å·æ¥åšå½¢å¦‚ some_str[i] çš„ç´¢å¼•ï¼Œå› ä¸ºæ¯ä¸ª Unicode å­—ç¬¦å¯èƒ½æœ‰å¤šä¸ªå­—èŠ‚ã€‚
* æ­£ç¡®çš„åšæ³•æ˜¯åœ¨ chars() ä¸­è¿­ä»£ï¼š
  * `for c in "1234".chars() { ... }`

#### 5.String
* String æ˜¯åˆ†é…åœ¨å †ä¸Šçš„ï¼Œå¯ä»¥åŠ¨æ€å¢é•¿ã€‚
  * å’Œ Vec ç±»ä¼¼ï¼Œå®é™…ä¸Šå°±æ˜¯åœ¨ `Vec<u8>` å¤–é¢åŒ…äº†ä¸€å±‚ã€‚
* ä¹Ÿä¸èƒ½ç”¨ä¸‹æ ‡æ¥ç´¢å¼•ã€‚
  * å¯ä»¥é€šè¿‡ `s.chars().nth(i) `æ¥è®¿é—®æŸä¸ªå­—ç¬¦ã€‚
* é€šè¿‡å–å¼•ç”¨çš„æ–¹å¼å¯ä»¥è·å¾— `&str`ã€‚
```rust
let s0: String = String::new();
let s1: String = "foo".to_string();
let s2: String = String::from("bar");
let and_s: &str = &s0;
```
#### 6.str
* å¦‚æœ &str æ˜¯ä¸€ç§å­—ç¬¦ä¸²ç±»å‹ï¼Œé‚£ä¹ˆ str åˆ°åº•æ˜¯ä»€ä¹ˆï¼Ÿ
* str æ˜¯ä¸€ç§ Unsized çš„ç±»å‹ï¼Œä¹Ÿå°±æ˜¯ç¼–è¯‘æ—¶å¤§å°æœªçŸ¥ã€‚
  * ä¸èƒ½ç›´æ¥ç»‘å®š strï¼Œåªèƒ½é€šè¿‡å¼•ç”¨çš„å½¢å¼æ¥ä½¿ç”¨ã€‚

#### 7.å­—ç¬¦ä¸²è¿æ¥æ“ä½œ
* å¯ä»¥ç”¨ + è¿æ¥ä¸€ä¸ª String å’Œä¸€ä¸ª &str ç±»å‹çš„å­—ç¬¦ä¸²ï¼ˆæ³¨æ„é¡ºåºï¼‰ï¼š
  ```rust
  let a = String::from("hello");
    let b = String::from(" world");
    let c = a + &b;
    // `a` is moved and can no longer be used here.
  ```
* å¦‚æœæƒ³ä¿ç•™ç¬¬ä¸€ä¸ª Stringï¼Œéœ€è¦åšä¸€ä»½å…‹éš† (clone)ï¼š
  ```rust
  let a = String::from("hello");
  let b = String::from(" world");
  let c = a.clone() + &b;
  // `a` is still valid here
  ```

  #### 8.å­—ç¬¦ä¸²è¿æ¥æ“ä½œå’Œå®ç°
  * å¦‚æœè¦è¿æ¥ä¸¤ä¸ª &strï¼Œéœ€è¦æŠŠç¬¬ä¸€ä¸ªè½¬æ¢æˆ Stringï¼š
  ```rust
  let a = "hello";
  let b = " world";
  let c = a.to_string() + b;
  ```
  * è¿æ¥æ“ä½œçš„å®ç°ä»£ç ï¼š
  ```rust
  fn add(mut self, other: &str) -> String {
    self.push_str(other);
    self
  }
  ```
#### 9.String ä¸ &str å¹¶å­˜çš„è®¾è®¡åŸå› 
* `&str` èƒ½å¤Ÿæä¾› String çš„ä¸€ä¸ªè§†å›¾ï¼Œæ­£å¦‚åˆ‡ç‰‡ä¹‹äº Vec å‘é‡é‚£æ ·ã€‚
* æ‹·è´ String çš„ä»£ä»·éå¸¸é«˜æ˜‚ï¼Œè€Œä¸”å€Ÿç”¨çš„æ—¶å€™å¹¶ä¸ä¸€å®šéœ€è¦æ•´ä¸ªå­—ç¬¦ä¸²ã€‚
* `&str` æä¾›äº†ä¸€ç§ä½å¼€é”€ä¼ é€’éƒ¨åˆ† String å­—ç¬¦ä¸²å†…å®¹çš„æ–¹æ³•ï¼Œè€Œä¸”èŠ‚çº¦å†…å­˜ã€‚
* ä¸€èˆ¬è€Œè¨€ï¼Œå¦‚æœè¦å¤„ç†å­—ç¬¦ä¸²ï¼Œä½¿ç”¨ Stringï¼ŒåŒæ—¶å¯ä»¥ç”¨ `&str` æ¥å€Ÿç”¨å…¶ä¸­çš„å†…å®¹ã€‚
 

## äºŒã€Optionæšä¸¾ç±»å‹
#### 1.Option<<T>T>ç±»å‹
```rust
enmu Option<T> {
  None,
  Some(T),
}
```
* `Option<T>`æ˜¯ä¸€ä¸ªæšä¸¾ç±»å‹ï¼ŒåŒæ—¶ä¹Ÿæ˜¯æ³›å‹ç±»å‹ã€‚
* ä¸ºæŸç§å·²æœ‰ç±»å‹æä¾›äº†è¡¨ç¤ºæ²¡æœ‰æˆ–è€…ç©ºå€¼çš„æ¦‚å¿µã€‚
* åœ¨ Rust ä¸­ï¼Œåœ¨éœ€è¦è¿”å›ç©ºå€¼æ—¶ï¼Œæ¨èä½¿ç”¨ `Option<T>`ã€‚
  * è€Œä¸æ˜¯è¿”å›è¯¸å¦‚ NaNã€-1ã€null ç­‰ç‰¹æ®Šçš„å€¼ã€‚
* ç±»å‹ T å¯ä»¥æ˜¯ä»»ä½•ç±»å‹ï¼Œæ²¡æœ‰é™åˆ¶ã€‚

#### 2.Option::unwrap()
* åœ¨å¤„ç† Option ç±»å‹çš„æ•°æ®æ—¶ï¼Œä¸€å®šä¼šé¢å¯¹ None çš„æƒ…å†µï¼Œå¿½ç•¥ None æ˜¯ä¸€ç§å¾ˆå¸¸è§çš„å¤„
ç†åŠæ³•ã€‚
```rust
// fn foo() -> Option<i32>
match foo() {
  None => (),
  Some(value) => {
    bar(value)
    // ...
  },
}
fn unwrap<T>(self) -> T {
  match self {
    None => panic!("Called `Option::unwrap()` on a `None` value"),
    Some(value) => value,
  }
}
let x = foo().unwrap();
let y = bar(x);
// ...
```
* `Option::unwrap()`åœ¨é‡åˆ°Noneæ—¶ä¼šææ…Œå¹¶è¾“å‡ºå›ºå®šçš„å†…å®¹ã€‚
* æ›´å¥½çš„åšæ³•æ˜¯è°ƒç”¨`expect(self, msg: &str) -> T`ã€‚
  * å®ƒå¯ä»¥åœ¨é‡åˆ° None æ—¶ä»¥æŒ‡å®šçš„ä¿¡æ¯æ‰§è¡Œææ…Œã€‚

#### 3.Option::map()
* å¦‚æœå¸Œæœ›å¯¹ä¸€ä¸ª Option è¿›è¡Œå˜æ¢ï¼Œä¹Ÿå°±æ˜¯æœ‰å€¼çš„æ—¶å€™ä½œç”¨ä¸€ä¸ªå‡½æ•°ï¼Œç©ºå€¼çš„æ—¶å€™ç»§ç»­ä¿
æŒç©ºå€¼ï¼Œå¯ä»¥è°ƒç”¨ï¼š
```rust
fn map<U, F>(self, f: F) -> Option<U>
where F: FnOnce(T) -> U {
    match self {
      None => None,
      Some(x) => Some(f(x))
    }
}
// fn foo() -> Option<i32>
let x = foo().map(|x| bar(x));
```

#### 4.Option::and_then()
* ç±»ä¼¼çš„è¿˜æœ‰and_then:
```rust
fn and_then<U, F>(self, f: F) -> Option<U>
where F: FnOnce(T) -> Option<U> {
  match self {
  Some(x) => f(x),
  None => None,
  }
}
// fn foo() -> Option<i32>
let x = foo().and_then(|x| Some(bar(x)));
```
* æ³¨æ„ï¼Œå’Œmapç›¸æ¯”ï¼Œfçš„ç±»å‹ä»T -> U å˜ä¸ºT -> Option(U)ã€‚
  
#### 5.Option::unwrap_or()
* å¦‚æœå¯¹äºç©ºå€¼çš„æƒ…å†µæœ‰åˆç†çš„é»˜è®¤å€¼ï¼Œå¯ä»¥ç”¨ unwrap_or æä¾›ã€‚
```rust
impl<T> Option<T> {
  fn unwrap_or<T>(self, default: T) -> T {
    match self {
      None => default,
      Some(value) => value,
    }
  }
}
```
#### 6.Option::unwrap_or_else()
* å¦‚æœé»˜è®¤å€¼ç”±é—­åŒ…è®¡ç®—è€Œæ¥ï¼Œåˆ™ä½¿ç”¨ unwrap_or_elseã€‚
```rust
impl<T> Option<T> {
  fn unwrap_or_else<T>(self, f: F) -> T
  where F: FnOnce() -> T {
    match self {
    None => f(),
    Some(value) => value,
    }
  }
}
```
#### 7.å…¶ä»–æ–¹æ³•
* `fn is_some(&self) -> bool`
* `fn is_none(&self) -> bool`
* `fn map_or<U, F>(self, default: U, f: F) -> U`
  * `where F: FnOnce(T) -> U`
  * U ç±»å‹çš„é»˜è®¤å€¼
* `fn map_or_else<U, D, F>(self, default: D, f: F) -> U`
  * `where D: FnOnce() -> U, F: FnOnce(T) -> U`
  * D ç±»å‹çš„é—­åŒ…ç”¨äºè®¡ç®—é»˜è®¤å€¼
* `fn ok_or(self, err: E) -> Result<T, E>`
* `fn ok_or_else(self, default: F) -> Result<T, E>`
  * `where F: FnOnce() -> E`
  * ä¸ unwrap_or ç›¸ä¼¼ï¼Œç”¨äºé”™è¯¯å¤„ç†ã€‚
* `fn and<U>(self, optb: Option<U>) -> Option<U>`
  * å¦‚æœ self æ˜¯ Noneï¼Œåˆ™è¿”å› Noneï¼Œå¦åˆ™è¿”å› optbã€‚
* `fn or(self, optb: Option<T>) -> Option<T>`
  * å¦‚æœ self æ˜¯ Some(_)ï¼Œåˆ™è¿”å› selfï¼Œå¦åˆ™è¿”å› optbã€‚
* `fn xor(self, optb: Option<T>) -> Option<T>`
  * å¦‚æœ self å’Œ optb æ°å¥½æœ‰ä¸€ä¸ªæ˜¯ Some(_)ï¼Œåˆ™è¿”å›è¿™ä¸ª Someï¼Œå¦åˆ™è¿”å› Noneã€‚

#### 8.Option ä¾‹å­
```rust
fn divide(numerator: f64, denominator: f64) -> Option<f64> {
  if denominator == 0.0 {
    None
  } else {
    Some(numerator / denominator)
  }
}

// The return value of the function is an option
let result = divide(2.0, 3.0);

// Pattern match to retrieve the value
match result {
  // The division was valid
  Some(x) => println!("Result: {x}"),
  // The division was invalid
  None => println!("Cannot divide by 0"),
}
```
## ä¸‰ã€é”™è¯¯å¤„ç†
#### 1.Rust çš„é”™è¯¯å¤„ç†æœºåˆ¶
* å¯¹äºä¸å¯æ¢å¤çš„é”™è¯¯ï¼Œä½¿ç”¨ææ…Œ panic!ã€‚
  * æ•°ç»„è¶Šç•Œã€æ ˆè¶Šç•Œã€ç®—æœ¯è¿ç®—æº¢å‡ºâ€¦â€¦
* å¯¹äºå¯æ¢å¤çš„é”™è¯¯ï¼Œä½¿ç”¨ Resultã€‚
  * æ–‡ä»¶æ“ä½œã€ç½‘ç»œæ“ä½œã€å­—ç¬¦ä¸²è§£æâ€¦â€¦
  
#### 2.Result<T, E>
```rust
enum Result<T, E> {
  Ok(T),
  Err(E)
}
```
* Result ä¸ Option ç±»ä¼¼ï¼Œé™¤äº†æ­£å¸¸ç»“æœå¤–ï¼Œè¿˜å¯ä»¥è¡¨ç¤ºé”™è¯¯çŠ¶æ€ã€‚
* ä¹Ÿå®šä¹‰äº† `unwrap` å’Œ `expect `ç­‰æ–¹æ³•ã€‚
* å¯ä»¥é€šè¿‡ ok æˆ– err ç­‰æ–¹æ³•è½¬æ¢æˆ Optionã€‚
  * æŠŠ Ok æˆ–è€… Err çš„å€¼ä½œä¸º Someï¼Œå¦ä¸€ç§å˜æˆ Noneã€‚
* ä¹Ÿå¯ä»¥è¿›è¡Œç±»ä¼¼ Option çš„æ“ä½œã€‚
  * andã€orã€â€¦â€¦

#### 3.Result<T, E> çš„å¤„ç†åŸåˆ™
* å¯¹äºè¿”å›ç»“æœæ˜¯ Result çš„å‡½æ•°ï¼Œä¸€å®šè¦æ˜¾å¼è¿›è¡Œå¤„ç†ã€‚
  * å¯ä»¥ä½¿ç”¨ `unwrap/expect`ï¼Œä¹Ÿå¯ä»¥é€šè¿‡åŒ¹é…åˆç†åœ°å¤„ç† Ok/Err çŠ¶æ€ã€‚
  * å¦‚æœä¸å¤„ç†ï¼Œç¼–è¯‘å™¨ä¼šå‘å‡ºè­¦å‘Šã€‚
  * ä¸æ­£ç¡®å¤„ç†å¯èƒ½ä¼šå¸¦æ¥æ½œåœ¨é—®é¢˜ï¼Œå¯¼è‡´æ„æƒ³ä¸åˆ°çš„æƒ…å†µã€‚

#### 4.è‡ªå®šä¹‰ Result åˆ«å
* ä¸€ç§å¸¸è§çš„åšæ³•æ˜¯åœ¨è‡ªå·±ç¼–å†™çš„åº“é‡Œä½¿ç”¨è‡ªå®šä¹‰çš„é”™è¯¯ç±»å‹ï¼Œå¹¶å®šä¹‰ Result çš„åˆ«åã€‚
```rust
use std::io::Error;

type Result<T> = Result<T, Error>;
```
* é™¤äº†å›ºå®š E = Error ä»¥å¤–ä¸ std::Result æ˜¯ç­‰ä»·çš„ã€‚
* ä½¿ç”¨çš„æ—¶å€™è¦æ³¨æ„åå­—ç©ºé—´ã€‚
```RUST
use std::io;

fn foo() -> io::Result {
  // ...
}
```
#### 5.? æ“ä½œç¬¦
* é…åˆ Result ç±»å‹
```RUST
fn read_username_from_file() -> Result<String, io::Error> {
  let mut username = String::new();
  File::open("hello.txt")?.read_to_string(&mut username)?;
  Ok(username)
}
```
* é…åˆ Option ç±»å‹
```rust
fn last_char_of_first_line(text: &str) -> Option<char> {
  text.lines().next()?.chars().last()
}
```
#### 6.? æ“ä½œç¬¦çš„åŸç†
* ä½œç”¨ï¼šæå‰ä¼ æ’­é”™è¯¯
* åœºåˆï¼šè¿”å›å€¼æ˜¯ Result æˆ–è€… Option å‡½æ•°ä¸­
* å¯¹äº Result ç±»å‹ï¼Œ
  * å¦‚æœæ˜¯ Err åˆ™æå‰è¿”å›ï¼Œå½“å‰å‡½æ•°ç«‹å³è¿”å›è¯¥é”™è¯¯ã€‚
  * å¦åˆ™ï¼Œä» Ok ä¸­å–å‡ºè¿”å›å€¼ä½œä¸º ? æ“ä½œç¬¦çš„ç»“æœã€‚
* å¯¹äº Option ç±»å‹ï¼Œ
  * å¦‚æœæ˜¯ None åˆ™æå‰è¿”å›ï¼Œå½“å‰å‡½æ•°ç«‹å³è¿”å› Noneã€‚
  * å¦åˆ™ï¼Œä» Some ä¸­å–å‡ºè¿”å›å€¼ä½œä¸º ? æ“ä½œç¬¦çš„ç»“æœã€‚

#### 7.é”™è¯¯å¤„ç†çš„åŸåˆ™
* ææ…Œï¼Œè¿˜æ˜¯ä¸ææ…Œï¼Ÿæ˜¯å¦è¦ç»™è°ƒç”¨ä»£ç æ¢å¤çš„æœºä¼šã€‚
* ç”¨ unwrap/expect çš„åœºåˆï¼š
  * unwrap/expect å¯ä»¥ä½œä¸ºåŸå‹ä»£ç ä¸­çš„é”™è¯¯å¤„ç†å ä½ç¬¦ã€‚
  * å½“ç”¨æˆ·æœ‰æ›´å¤šçš„ä¿¡æ¯ï¼Œèƒ½å¤Ÿä¿è¯è°ƒç”¨ä¸å‡ºé”™ã€‚
* åŸåˆ™ï¼šé”™è¯¯å‘ç”Ÿåç¨‹åºæ˜¯å¦è¿›å…¥ä¸€ä¸ªåçš„çŠ¶æ€ï¼Ÿ
  * åçš„çŠ¶æ€æ˜¯æŒ‡ä¸ç»å¸¸å‡ºç°çš„æƒ…å†µï¼Œè€Œä¸æ˜¯åƒç”¨æˆ·è¾“å…¥ä¸åˆæ³•è¿™æ ·ç»å¸¸å¯èƒ½å‡ºç°çš„æƒ…å†µã€‚
  * ä¹‹åçš„ä»£ç ä¼šä¾èµ–ç¨‹åºä¸å¤„äºåçš„çŠ¶æ€ï¼Œè€Œä¸æ˜¯æ¯ä¸€æ­¥éƒ½å»æ£€æŸ¥çŠ¶æ€ã€‚
  * æ²¡æœ‰åŠæ³•ç”¨ç›®å‰ä½¿ç”¨çš„ç±»å‹æ¥è¡¨ç¤ºè¿™ç§ä¿¡æ¯ã€‚

## å››ã€å®¹å™¨
#### 1.Vec<T<T>>
* è¿ç»­ç©ºé—´ã€å¯å¢é•¿çš„åºåˆ—ï¼Œæœ«å°¾å¯ä»¥é«˜æ•ˆå¢åˆ 
* ä¼šå‘ç”Ÿå¢é•¿å’Œæ”¶ç¼©
* æœ€å¸¸ç”¨çš„å®¹å™¨

#### 2.VecDeque<T<T>>
* åŒç«¯å‘é‡ï¼Œä¸¤ç«¯å¯ä»¥é«˜æ•ˆå¢åˆ 
* ç”¨ç¯çŠ¶ç¼“å†²åŒºæ¥å®ç°

#### 3.LinkedList<T<T>>
* åŒå‘é“¾è¡¨
* ä¸èƒ½éšæœºç´¢å¼•

#### 4.HashMap<K,V>/BTreeMap<K,V>
* æ˜ å°„/å­—å…¸ç±»å‹
* ä¸€èˆ¬ä½¿ç”¨ `HashMap<K, V>`
  * éœ€è¦æ»¡è¶³ K: Hash + Eq
  * ä½¿ç”¨å“ˆå¸Œè¡¨å®ç°ï¼Œæ²¡æœ‰é¡ºåºï¼Œæ•ˆç‡è¾ƒé«˜ï¼Œğ‘‚(1) çš„è®¿å­˜å¤æ‚åº¦
* éœ€è¦æœ‰åºçš„æ—¶å€™ç”¨ `BTreeMap<K, V>`
  * éœ€è¦æ»¡è¶³ K: Ord
  * ä½¿ç”¨ B æ ‘å®ç°ï¼Œæœ‰åºï¼Œæ•ˆç‡ç›¸å¯¹ä½ä¸€äº›ï¼Œğ‘‚(log ğ‘›) çš„è®¿å­˜å¤æ‚åº¦

#### 5.åˆ›å»ºæ–°çš„å“ˆå¸Œè¡¨
```rust
use std::collections::HashMap;

let mut scores = HashMap::new();

scores.insert(String::from("Blue"), 10);
scores.insert(String::from("Yellow"), 50);
```
#### 6.è®¿é—®å“ˆå¸Œè¡¨çš„å…ƒç´ 
```rust
let mut scores = HashMap::new();

scores.insert(String::from("Blue"), 10);
scores.insert(String::from("Yellow"), 50);

let team_name = String::from("Blue");
let score = scores.get(&team_name);
```
#### 7.è¿­ä»£å“ˆå¸Œè¡¨
```rust
let mut scores = HashMap::new();

scores.insert(String::from("Blue"), 10);
scores.insert(String::from("Yellow"), 50);

for (key, value) in &scores {
println!("{}: {}", key, value);
}
```
#### 8.å“ˆå¸Œè¡¨å’Œæ‰€æœ‰æƒ
* å¯¹äº Copy ç±»å‹ï¼Œæ‹·è´è¿›å“ˆå¸Œè¡¨ã€‚
* å¯¹äºé Copy ç±»å‹ï¼Œç§»åŠ¨è¿›å“ˆå¸Œè¡¨ï¼Œå“ˆå¸Œè¡¨æ‹¥æœ‰æ‰€æœ‰æƒã€‚
```rust
let field_name = String::from("Favorite color");
let field_value = String::from("Blue");

let mut map = HashMap::new();
map.insert(field_name, field_value);
// field_name and field_value are invalid at this point, try using
// them and see what compiler error you get!
```
#### 9.æ›´æ–°å“ˆå¸Œè¡¨
* æ”¹å†™
```rust
scores.insert(String::from("Blue"), 10);
```
* ä¸å­˜åœ¨æ—¶æ·»åŠ 
```rust
scores.entry(String::from("Blue")).or_insert(50);
```
* åŸºäºæ—§å€¼æ›´æ–°
```rust
let text = "hello world wonderful world";
let mut map = HashMap::new();
for word in text.split_whitespace() {
  let count = map.entry(word).or_insert(0);
  *count += 1;
}
```
#### 10.HashSet<T<T>>/BTreeSet<T<T>>
* é›†åˆï¼Œå…ƒç´ æ˜¯å”¯ä¸€çš„
* `HashSet<T>` å’Œ`BTreeSet<T> `å°±æ˜¯åœ¨ `HashMap<T, ()> `å’Œ `BTreeMap<T, ()> `ä¸Š
åŒ…äº†ä¸€å±‚ã€‚
* éœ€æ±‚å’Œè¡¨ç°è·Ÿç›¸åº”çš„ Map ç›¸åŒã€‚

#### 11.BinaryHeap<T<T>>
* ç”¨äºŒå‰æœ€å¤§å †å®ç°çš„ä¼˜å…ˆçº§é˜Ÿåˆ—
* å¼¹å‡ºå…ƒç´ æ—¶è¿”å›ç›®å‰å †ä¸­çš„æœ€å¤§å€¼
  
## äº”ã€è¿­ä»£å™¨
#### 1.è¿­ä»£å™¨çš„å®šä¹‰
```rust
pub trait Iterator {
  type Item;
  fn next(&mut self) -> Option<Self::Item>;
  // More fields omitted
}
```
* è¿­ä»£å™¨ç‰¹å‹åŒ…å«ä¸€ä¸ªç›¸å…³çš„ç±»å‹ Itemï¼Œä»¥åŠä¼šäº§ç”Ÿè¯¥ç±»å‹å¯¹è±¡çš„æ–¹æ³• nextã€‚
* å…¶ä»–æ–¹æ³•ï¼ˆåŒ…æ‹¬æ¶ˆè´¹è€…å’Œé€‚é…å™¨ï¼‰æœ‰ä½¿ç”¨ next çš„é»˜è®¤å®ç°ç‰ˆæœ¬ã€‚

#### 2.è¿­ä»£å™¨ä¸æ‰€æœ‰æƒ
* æœ‰ä¸‰ç§è¿­ä»£ç±»å‹ï¼š
  * `into_iter()`ï¼Œäº§ç”Ÿ T ç±»å‹ã€‚
  * `iter()`ï¼Œäº§ç”Ÿ &T ç±»å‹ã€‚
  * `iter_mut()`ï¼Œäº§ç”Ÿ &mut Tã€‚
* é›†åˆå¯ä»¥æä¾›éƒ¨åˆ†æˆ–è€…å…¨éƒ¨æ¥å£ã€‚  

#### 3.è¿­ä»£å™¨ä¸å¾ªç¯
* è¿­ä»£å™¨ä¸ for ... in ... å¾ªç¯çš„è¯­æ³•ç³–ï¼Œfor x in values ä¼šå±•å¼€ä¸ºï¼š
```rust
let values = vec![1, 2, 3, 4, 5];
{
  let result = match values.into_iter() {
    mut iter => loop {
      match iter.next() {
        Some(x) => { /* loop body */ },
        None => break,
      }
    },
  };
  result
}
```
#### 4.è¿­ä»£å™¨çš„ç±»å‹è½¬æ¢æ“ä½œ
* è¿­ä»£å™¨çš„å¤„ç†å™¨æ¥å— `Iterator`ï¼Œè¿”å›å…¶ä»–ç±»å‹ã€‚
  * ä¾‹å¦‚ï¼Œ`map` è¿”å› Mapï¼Œ`filter` è¿”å› Filterã€‚
* è¿™äº›ç±»å‹ä¹Ÿæ˜¯å®ç°äº† Iterator çš„ç»“æ„ä½“ã€‚
  * ä¸ç”¨å¤ªçº ç»“å®ƒä»¬çš„å†…éƒ¨ç»“æ„ã€‚
* ç±»å‹è½¬æ¢ä¸»è¦ç”¨äºç¡®ä¿ç±»å‹å®‰å…¨ã€‚

#### 5.collect
* `collect()` æŠŠï¼ˆæƒ°æ€§çš„ï¼‰è¿­ä»£å™¨å˜æˆä¸€ä¸ªå®é™…çš„é›†åˆã€‚
* `collect()` æœ‰æ—¶å€™éœ€è¦æä¾›ç±»å‹æç¤ºæ¥é€šè¿‡ç¼–è¯‘ã€‚
  * ç»“æœå¯ä»¥æ˜¯ä»»ä½•çš„é›†åˆï¼ˆæˆ–è€…å®¹å™¨ï¼‰ã€‚
```rust
fn collect<B>(self) -> B where B: FromIterator<Self::Item>

let vs = vec![1, 2, 3, 4];
// Error: What type is this? It cannot infer!
let set = vs.iter().collect();
// Hint to `collect` that we want a HashSet back.
// Note the lack of an explicit <&i32>.
let set: HashSet<_> = vs.iter().collect();
// Alternate syntax! The "turbofish" ::<>
let set = vs.iter().collect::<HashSet<_>>();
```
#### 6.fold
```rust
fn fold<B, F>(self, init: B, f: F) -> B
  where F: FnMut(B, Self::Item) -> B;

let vs = vec![1, 2, 3, 4, 5];
let sum = vs.iter().fold(0, |acc, &x| acc + x);
assert_eq!(sum, 15);
```
* fold æŠŠè¿­ä»£å™¨æŠ˜å æˆä¸€ä¸ªå•ä¸€çš„å€¼ã€‚
  * åœ¨å…¶ä»–è¯­è¨€æˆ–è€…ç³»ç»Ÿé‡Œä¹Ÿç§°ä¸º reduce æˆ– inject æ“ä½œã€‚
* fold æœ‰ä¸¤ä¸ªå‚æ•°ï¼š
  * åˆå§‹å€¼ï¼Œæˆ–è€…ç§¯ç´¯å€¼ï¼ŒB ç±»å‹çš„ acc
  * ä¸€ä¸ªâ€œæŠ˜å â€å‡½æ•°ï¼Œå‚æ•°æ˜¯ä¸€ä¸ª B ç±»å‹å’Œä¸€ä¸ª Item ç±»å‹ï¼Œè¿”å›å€¼æ˜¯ B ç±»å‹ã€‚

#### 7.filter
```rust
fn filter<P>(self, predicate: P) -> Filter<Self, P>
  where P: FnMut(&Self::Item) -> bool;
```
* filter æ¥å—ä¸€ä¸ªè°“è¯å‡½æ•° Pï¼ŒæŠŠä¸ç¬¦åˆè°“è¯çš„å…ƒç´ éƒ½å»æ‰ã€‚
* filter è¿”å› Filter<Self, P>ï¼Œéœ€è¦ç”¨ collect è·å¾—é›†åˆã€‚

#### 8.find å’Œ position
```rust
fn find<P>(&mut self, predicate: P) -> Option<Self::Item>
  where P: FnMut(Self::Item) -> bool;

fn position<P>(&mut self, predicate: P) -> Option<usize>
  where P: FnMut(Self::Item) -> bool;
```
* æ‰¾å‡ºè¿­ä»£å™¨ä¸­ç¬¬ä¸€ä¸ªæ»¡è¶³è°“è¯å‡½æ•° predicate çš„é¡¹ç›®ã€‚
  * `find` è¿”å›é¡¹ç›®æœ¬èº«ã€‚
  * `position`è¿”å›é¡¹ç›®çš„ç´¢å¼•ã€‚
* æ²¡æ‰¾åˆ°éƒ½è¿”å› Noneã€‚

#### 9.skip
```rust
fn skip(self, n: usize) -> Skip<Self>;
```
* è¿”å›ä¸€ä¸ªæ–°çš„è¿­ä»£å™¨ï¼Œè·³è¿‡å‰ n ä¸ªå…ƒç´ ã€‚

#### 10.zip
```rust
fn zip<U>(self, other: U) -> Zip<Self, U::IntoIter>
  where U: IntoIterator;
```
* æŠŠä¸¤ä¸ªè¿­ä»£å™¨é€é¡¹åˆå¹¶æˆä¸€ä¸ªæ–°çš„è¿­ä»£å™¨ã€‚
* è°ƒç”¨å½¢å¼ï¼ša.iter().zip(b.iter())
  * è¿”å›é¡¹ç›®çš„å½¢å¼ï¼š(ai, bi)
* å½“ä¸€ä¸ªè¾“å…¥è¿­ä»£å™¨ç»“æŸæ—¶ï¼Œæ•´ä¸ª zip è¾“å‡ºçš„è¿­ä»£å™¨ç»“æŸã€‚
#### 11.any & all
```rust
fn any<F>(&mut self, f: F) -> bool
  where F: FnMut(Self::Item) -> bool;

fn all<F>(&mut self, f: F) -> bool
  where F: FnMut(Self::Item) -> bool;
```
* any æµ‹è¯•æ˜¯å¦è¿­ä»£å™¨ä¸­çš„å­˜åœ¨å…ƒç´ ç¬¦åˆè¾“å…¥å‡½æ•°ã€‚
* all æµ‹è¯•æ˜¯å¦è¿­ä»£å™¨ä¸­çš„æ‰€æœ‰æ‰€æ„¿éƒ½ç¬¦åˆè¾“å…¥å‡½æ•°ã€‚
* é€»è¾‘æˆ–å’Œé€»è¾‘ä¸çš„å…³ç³»

#### 12.enumerate
```rust
fn enumerate(self) -> Enumerate<Self>;
```
* ç”¨äºè¿­ä»£é›†åˆæ—¶åŒæ—¶éœ€è¦é¡¹ç›®å’Œç´¢å¼•ã€‚
* è¿”å› (index, value) çš„è¿­ä»£å™¨ï¼Œindex æ˜¯ usize ç±»å‹çš„ç´¢å¼•ã€‚
  
#### 13.è¿­ä»£å™¨é€‚é…
* é€‚é…å™¨ (adapters) æ“ä½œä¸€ä¸ªè¿­ä»£å™¨ï¼Œè¿”å›å¦ä¸€ä¸ªè¿­ä»£å™¨ã€‚
* é€‚é…å™¨é€šå¸¸æ˜¯**æƒ°æ€§çš„**ï¼šé™¤éä¸å¾—ä¸åšï¼Œä¸ç„¶å…ˆä¸å»æ±‚å€¼ã€‚
* å¿…é¡»æ˜¾å¼ä½¿ç”¨æˆ–è€…ç”¨ for å¾ªç¯è¿­ä»£æ‰ä¼šå»æ±‚å€¼ã€‚

#### 14.map
```rust
fn map<B, F>(self, f: F) -> Map<Self, F>
  where F: FnMut(Self::Item) -> B;

let vs = vec![1, 2, 3, 4, 5];
let twice_vs: Vec<_> = vs.iter().map(|x| x * 2).collect();
```
* map æ¥å—ä¸€ä¸ªå‡½æ•°ï¼Œåˆ›å»ºä¸€ä¸ªè¿­ä»£å™¨ï¼Œåœ¨æ¯ä¸ªå…ƒç´ ä¸Šè°ƒç”¨è¿™ä¸ªå‡½æ•°ã€‚
* å®Œæˆä»é›†åˆ `Collection<A>` å’Œ A -> B å‡½æ•°å¾—åˆ° `Collection<B>` çš„æ“ä½œã€‚
  * è¿™é‡Œï¼ŒCollection ä¸æ˜¯ä¸€ç§å®é™…çš„ç±»å‹ã€‚
  
#### 15.take å’Œ take_while
```rust
fn take(self, n: usize) -> Take<Self>;

fn take_while<P>(self, predicate: P) -> TakeWhile<Self, P>
  where P: FnMut(&Self::Item) -> bool;
```
* take åˆ›å»ºä¸€ä¸ªè¿­ä»£å™¨ï¼Œè¿”å›å‰ n ä¸ªå…ƒç´ ã€‚
* take_while æ¥å—ä¸€ä¸ªè°“è¯ï¼Œè¿­ä»£ç›´åˆ°è°“è¯è¿”å› falseã€‚
* å¯ä»¥åœ¨æ— é™èŒƒå›´ä¸Šä½¿ç”¨å¾—åˆ°æœ‰é™åºåˆ—ï¼š
```rust
for i in (0..).take(5) {
  println!("{}", i); // Prints 0 1 2 3 4
}
```
#### 16.cloned
```rust
fn cloned<'a, T>(self) -> Cloned<Self>
  where T: 'a + Clone, Self: Iterator<Item=&'a T>;
```
* åˆ›å»ºä¸€ä¸ªè¿­ä»£å™¨ï¼Œåœ¨æ¯ä¸ªå…ƒç´ ä¸Šè°ƒç”¨ clone æ–¹æ³•ã€‚
* ç›¸å½“äº vs.iter().map(|v| v.clone())ã€‚
* åœ¨ç›®å‰æœ‰ &T è¿­ä»£å™¨ï¼Œæƒ³æœ‰ T è¿­ä»£å™¨çš„æ—¶å€™ä½¿ç”¨ã€‚
  
## å…­ã€è‡ªåŠ¨æµ‹è¯•
#### 1.æµ‹è¯•å‡½æ•°
å•å…ƒæµ‹è¯•æ˜¯å¾ˆå¸¸è§ä¸”å¿…è¦çš„åŠŸèƒ½ï¼Œå› æ­¤ Rust è‡ªå¸¦äº†æµ‹è¯•çš„æ”¯æŒã€‚
                                  
Rust ä¸­ç”¨å‡½æ•°æ¥å®ç°å•å…ƒæµ‹è¯•ï¼Œå‡½æ•°å‰é¢åŠ ä¸Š `#[test]` æ ‡æ³¨è¿™æ˜¯ä¸€ä¸ªæµ‹è¯•å‡½æ•°ï¼š
```rust
#[test]
fn it_works() {
  let result = 2 + 2;
  assert_eq!(result, 4);
}
```
#### 2.è¿è¡Œæµ‹è¯•
ä¸ºäº†è¿è¡Œé¡¹ç›®ä¸­çš„æ‰€æœ‰æµ‹è¯•å‡½æ•°ï¼Œå¯ä»¥ç”¨ cargo test å‘½ä»¤ï¼š
```rust
$ cargo test
running 1 test
test tests::it_works ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out;
finished in 0.00s
```
å®ƒä¼šæ±‡æŠ¥æ¯ä¸ªæµ‹è¯•çš„ç»“æœï¼Œå¹¶æœ€åç»™å‡ºæ‰€æœ‰æµ‹è¯•é€šè¿‡æƒ…å†µçš„ç»Ÿè®¡ä¿¡æ¯ã€‚

#### 3.ç¼–å†™æµ‹è¯•
ä¸ºäº†ç¡®è®¤ç¨‹åºè¡Œä¸ºç¬¦åˆé¢„æœŸï¼Œä¸€èˆ¬å¯ä»¥ç”¨å¦‚ä¸‹çš„æ–¹å¼è¿›è¡Œæ£€æŸ¥ï¼š
* assert!() å®ï¼Œæ–­è¨€ä¸€ä¸ªå€¼ä¸€å®šæ˜¯ true
* assert_eq!() å®ï¼Œæ–­è¨€ä¸¤ä¸ªå€¼ä¸€å®šç›¸ç­‰
* Option::unwrap æˆ– Option::expectï¼Œæ–­è¨€ä¸€ä¸ª Option ç±»å‹çš„å€¼ä¸€å®šæ˜¯ Some(_)
```rust
#[test]
fn it_works() {
  let result = 2 + 2;
  assert_eq!(result, 4);
}
```
åœ¨æµ‹è¯•å‡½æ•°ä¸­å‡ºç°çš„panic ä¼šè¢«æ•æ‰ä¸‹æ¥ï¼Œå¹¶æ ‡è®°å½“å‰æµ‹è¯•å¤±è´¥ï¼Œè€Œä¸ä¼šé€€å‡ºç¨‹åºã€‚
#### 4.æµ‹è¯•ä¾‹å­
é€šå¸¸ä¼šæŠŠå•å…ƒæµ‹è¯•ä¸è¢«æµ‹è¯•çš„ä»£ç æ”¾åœ¨åŒä¸€ä¸ªæ–‡ä»¶ä¸­ï¼š
```rust
fn vector_length(data: &Vec<i32>) -> usize {
  vector_length.len()
}

#[test]
fn test_vector_length() {
  assert_eq!(vector_length(&vec![1, 2, 3]), 3);
}
```
å…»æˆè‰¯å¥½çš„ä¹ æƒ¯ï¼šæ¯å†™ä¸€ä¸ªå‡½æ•°ï¼Œå°±åœ¨æ–‡ä»¶åé¢å®ç°å¯¹å®ƒçš„å•å…ƒæµ‹è¯•ã€‚

#### 5.æµ‹è¯•ä¾‹å­ï¼ˆå­æ¨¡å—ï¼‰
æœ‰æ—¶å€™ï¼Œæˆ‘ä»¬ä¼šå¸Œæœ›æµ‹è¯•ä»£ç ä»…åœ¨æµ‹è¯•æ¨¡å¼ä¸‹ç¼–è¯‘ï¼Œè¿™æ ·ä¸ä¼šæ‹–ç´¯æ­£å¸¸ç¼–è¯‘çš„æ—¶é—´ã€‚æ­¤æ—¶å¯ä»¥ä½¿ç”¨ `#[cfg(test)]` å®ç°æ¡ä»¶ç¼–è¯‘ï¼š
```rust
fn vector_length(data: &Vec<i32>) -> usize { vector_length.len() }

#[cfg(test)]
mod tests {
  use super::vector_length;

  #[test]
  fn test_vector_length() {
    assert_eq!(vector_length(&vec![1, 2, 3]), 3);
  }
}
```
#### 6.æ›´å¤šæµ‹è¯•é€‰é¡¹
é»˜è®¤æƒ…å†µä¸‹ï¼Œ`cargo test` ä¼šåŒæ—¶è¿è¡Œå¤šä¸ªæµ‹è¯•ä»¥åŠ å¿«é€Ÿåº¦ã€‚å¦‚æœä½ çš„æµ‹è¯•åœ¨åŒæ—¶è¿è¡Œçš„æƒ…å†µ
ä¸‹å¯èƒ½å‡ºé”™ï¼Œæˆ–è€…å¸Œæœ›å®ƒæŒ‰é¡ºåºæ‰§è¡Œï¼Œé‚£ä¹ˆå¯ä»¥ä½¿ç”¨ `cargo test----test-threads=1`å‘½ä»¤æ¥æŒ‡å®šå®ƒåŒæ—¶åªè¿›è¡Œä¸€ä¸ªæµ‹è¯•ã€‚

å¦‚æœæƒ³è¦æŒ‡å®šåªè¿è¡Œå•ä¸ªæµ‹è¯•ï¼Œå¯ä»¥ä½¿ç”¨ cargo test -- test_2 å‘½ä»¤æ¥ä»…è¿è¡Œ test_2 è¿™ä¸ªæµ‹è¯•ï¼š
```rust
#[test]
fn test_1() { }

#[test]
fn test_2() { }
```
#### 7.æŒç»­é›†æˆæµ‹è¯•
å¤§ä½œä¸šä»“åº“é…ç½®äº†æŒç»­é›†æˆæµ‹è¯•ï¼Œæ¯æ¬¡ Git Push éƒ½ä¼šåœ¨äº‘ç«¯è‡ªåŠ¨æ‰§è¡Œä¸€æ¬¡ cargo testï¼š
```rust
test:
  image: jiegec/rust:1.63-bullseye-tuna
  script:
    - cargo build
    - cargo test -- --test-threads=1
```
